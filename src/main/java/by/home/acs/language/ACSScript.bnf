{
  parserClass="by.home.acs.language.parser.ACSScriptParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  extends("ParenthesisedExpression|BinaryExpression|FunctionInvocation|LiteralExpression")=AssignmentExpression
  extends("DefineParenthesesExpression|DefineBinaryExpression|DefineLiteralExpression")=DefineExpression

  psiClassPrefix="ACSScript"
  psiImplClassSuffix="Impl"
  psiPackage="by.home.acs.language.psi"
  psiImplPackage="by.home.acs.language.psi.impl"

  elementTypeHolderClass="by.home.acs.language.ACSScriptTypes"
  elementTypeClass="by.home.acs.language.psi.ACSScriptElementType"
  tokenTypeClass="by.home.acs.language.psi.ACSScriptTokenType"

  psiImplUtilClass="by.home.acs.language.psi.impl.ACSScriptPsiImplUtil"
  generate=[tokens="yes"]

  tokens = [
          FUNCTION='function'
                  SCRIPT='script'
                  WHITE_SPACE = 'regexp:\s+'
                  NUMBER='regexp:(0[xX][0-9a-fA-F]+)|(-?[0-9]+)'
                  STRING = 'regexp:\"([^\\\"]|\\.)*\"'
                  VOID = 'void'
                  INT = 'int'
                  STR = 'str'
                  BOOl = 'bool'
                  COMMA = ','
                  IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
      ]
}


ACSScriptFile ::= FileContainer

private FileContainer ::= (COMMENT|Definition*)

Definition ::= (FunctionDefinition | ScriptDefinition | DirectivesDeclaration | GlobalModifier | SpecialDefinition | VariableDefinition)
 {  mixin="by.home.acs.language.psi.impl.ACSNamedElementImpl"
    implements="by.home.acs.language.psi.ACSNamedElement"
    methods=[getName setName getNameIdentifier getNameIdentifier getFunctionKeyword getFunctionStatementReturnType]
 }

/**
    Specials declaration
 */

SpecialDefinition ::= SpecialIdentifier SpecialExpression Semicolon

SpecialIdentifier ::= special

SpecialExpression ::= (NUMBER Colon FunctionInvocation) (CommaSymbol SpecialExpression)*


FunctionDefinition ::= FunctionIdentifier FunctionReturnType FunctionNameAndParams FunctionBody

ScriptDefinition ::= ScriptIdentifier ScriptName (ScriptPossibleParams | ScriptType) (NetType ClientsideType | NetType | ClientsideType)? ScriptBody
/**
    Directives statement
 */
DirectivesDeclaration ::= (IncludeDeclaration | ImportDeclaration | DefineDeclaration | LibraryDeclaration)

IncludeDeclaration ::= IncludeKey STRING

ImportDeclaration ::= ImportKey STRING

DefineDeclaration ::= DefineKey IDENTIFIER  DefineExpression

LibraryDeclaration ::= LibraryKey STRING

/**
    Directives keywords
 */

DefineKey ::= '#define'

IncludeKey ::= '#include'

ImportKey ::= '#import'

LibraryKey ::= '#library'

DefineExpression ::= DefineParenthesesExpression | DefineBinaryExpression | DefineLiteralExpression

DefineParenthesesExpression ::= OpenBracket DefineExpression CloseBracket

DefineBinaryExpression ::= DefineExpression Operator DefineExpression

DefineLiteralExpression ::= NUMBER | FLOAT | STRING | IDENTIFIER

/**
    Script statements
 */
ScriptIdentifier ::= SCRIPT

ScriptType ::= OPEN | ENTER | RETURN | RESPAWN | DEATH | LIGHTNING | UNLOADING | DISCONNECT | KILL | REOPEN | PICKUP | REDRETURN | BLUERETURN | WHITERETURN

ScriptName ::= (STRING | NUMBER)

ScriptPossibleParams ::= OpenBracket (ScriptParameterWithVoid | ScriptParameter) CloseBracket

ScriptParameterWithVoid ::=  VoidType

ScriptParameter ::= ScriptParameterList

ScriptParameterList ::= ScriptFormalParameter (CommaSymbol ScriptFormalParameter)*

ScriptFormalParameter ::= IntType IDENTIFIER

ScriptBody ::= OpenBrace Statement* CloseBrace

/**
    Function statements
 */
FunctionIdentifier ::= FUNCTION

FunctionInvocation ::= IDENTIFIER OpenBracket FunctionInvokeParameters* CloseBracket

FunctionInvokeParameters ::= LiteralExpression (CommaSymbol LiteralExpression)*

FunctionReturnType ::= VoidType | Type

FunctionParameterWithVoid ::= VoidType

FunctionNameAndParams ::= IDENTIFIER OpenBracket FunctionParameter CloseBracket

FunctionParameter ::=  (FunctionParameterWithVoid | FunctionParameterList)

FunctionParameterList ::= FunctionFormalParameter (CommaSymbol FunctionFormalParameter)*

FunctionFormalParameter ::= Type IDENTIFIER

FunctionBody ::= OpenBrace Statement* CloseBrace

/**

 */

GlobalModifier ::= (global | world) Type NUMBER Colon IDENTIFIER Semicolon

StaticModifier ::= static

NetType ::= NET

ClientsideType ::= CLIENTSIDE

VoidType ::= VOID

TerminateKeyword ::= terminate Semicolon

Statement ::= (StatementWithoutSub | VariableDefinition | AssignmentStatement | FunctionInvocation Semicolon | IfThenElseStatement | IfThenStatement | Loops | SwitchLoop)

StatementWithoutSub ::= (CodeBlock | BreakStatement | ContinueStatement | ReturnOperator | TerminateKeyword)

CodeBlock ::= OpenBrace Statement* CloseBrace

BinaryExpression ::= AssignmentExpression Operator AssignmentExpression

AssignmentExpression ::= (ParenthesisedExpression | BinaryExpression | FunctionInvocation | LiteralExpression)

AssignmentStatement ::= IDENTIFIER Equals (FunctionInvocation Semicolon| VariableInitialization)

VariableDefinition ::= StaticModifier? Type VariableName ArrayType? (Semicolon | (Equals VariableInitialization))

left VariableName ::=  IDENTIFIER  (CommaSymbol VariableName)*

//VariableInitialization ::= AllTypes (CommaSymbol VariableName Equals AllTypes)*
VariableInitialization ::= (AssignmentExpression | SimpleInitialization) Semicolon

ParenthesisedExpression ::= OpenBracket AssignmentExpression CloseBracket

SimpleInitialization ::= AllTypes (CommaSymbol VariableName Equals AllTypes)*

LiteralExpression ::= (AllTypes | IDENTIFIER)

Operator ::= (BitwiseOperator | RelationalOperator | AssignmentOperator | ArithmeticOperator | LogicalOperator)

AssignmentOperator ::= ('=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|=')

RelationalOperator ::= ('>' | '<' | '==' | '!=' | '>=' | '<=')

ArithmeticOperator ::= ( '++' | '--' | '+' | '-' | '/' | '%' | '*' )

LogicalOperator ::= ('&&' | '||' | '!')

BitwiseOperator ::= ('&' | '|' | '^' | '~' | '<<' | '>>')

Loops ::= ForLoop | whileLoop | untilLoop | doWhileLoop | doUntilLoop

ForLoop ::= for OpenBracket Initialization Condition Iteration CloseBracket Statement

private Initialization ::= EmptyInitialization | TypeInitialization

EmptyInitialization ::= Semicolon

TypeInitialization ::= StaticModifier? Type VariableList  ArithmeticInitialization* Semicolon

private VariableList ::= VariableName Equals (NUMBER | STRING | IDENTIFIER | LogicalType) (CommaSymbol VariableList)?//check logical type

private ArithmeticInitialization ::= ArithmeticOperator (NUMBER | STRING | IDENTIFIER)

private Condition ::= (EmptyCondition | (NormalCondition Semicolon) | ArithmeticCondition)

private LogicalCondition ::= RelationalOperator

private ComparisonCondition ::= (IDENTIFIER | NUMBER | STRING) LogicalCondition (IDENTIFIER ArithmeticInitialization*| NUMBER ArithmeticInitialization* | STRING ArithmeticInitialization*| LogicalType) (LogicalOperator ComparisonCondition)?

NormalCondition ::= ComparisonCondition (LogicalCondition ComparisonCondition)?

private ArithmeticCondition ::= NormalCondition Semicolon LogicalOperator

EmptyCondition ::= Semicolon

private Iteration ::=  NormalIteration | EmptyIteration

EmptyIteration ::= //not sure with this...

NormalIteration ::= IDENTIFIER (ArithmeticOperator | ArithmeticOperator IDENTIFIER | IDENTIFIER AssignmentOperator (NUMBER | STRING | LogicalType | IDENTIFIER)) (CommaSymbol NormalIteration)?

whileLoop ::= while OpenBracket AssignmentExpression CloseBracket Statement

untilLoop ::= until OpenBracket AssignmentExpression CloseBracket Statement

doWhileLoop ::= do Statement while OpenBracket AssignmentExpression CloseBracket Semicolon

doUntilLoop ::= do Statement until OpenBracket AssignmentExpression CloseBracket Semicolon

Type ::= (IntType | StringType | BoolType)

private AllTypes ::= STRING | CHARACTER | EmptyString | LogicalType | ArrayInitializer | NUMBER | FLOAT

BoolType ::= BOOL

IntType ::= INT

StringType ::= STR

EmptyString ::= '""'

ArrayType ::=  OpenSquareBracket NUM CloseSquareBracket

ArrayInitializer ::= OpenBrace ArrayInitializers? CloseBrace

ArrayInitializers ::= (NUMBER | STRING) (CommaSymbol ArrayInitializers)?

LogicalType ::= true | false

ReturnOperator ::= return Semicolon | return BinaryExpression Semicolon | return IDENTIFIER Semicolon // Use something else but IDENTIFIER later

/**
    Control Flow Statements
 */

IfThenStatement ::= if OpenBracket AssignmentExpression CloseBracket (Statement | IfThenElseStatement)

IfThenElseStatement ::= if OpenBracket AssignmentExpression CloseBracket Statement else Statement

SwitchLoop ::= switch OpenBracket (IDENTIFIER | NUMBER) CloseBracket OpenBrace CaseOperator CloseBrace

CaseOperator ::=   CaseIdentifier Statement*  (default Colon Statement)? CaseOperator?

private CaseIdentifier ::= case (IDENTIFIER | NUMBER | STRING) Colon

/*
    Key symbol's
 */
Equals ::= '='

Dot ::= '.' //not used

CommaSymbol ::= COMMA

OpenBrace ::= '{'

CloseBrace ::= '}'

OpenBracket ::= '('

CloseBracket ::= ')'

Semicolon ::= ';'

Colon ::= ':'

OpenSquareBracket ::= '['

CloseSquareBracket ::= ']'

NUM ::= NUMBER

/**
    Loop Statements
 */

BreakStatement ::= break Semicolon

ContinueStatement ::= continue Semicolon

