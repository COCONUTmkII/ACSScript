{
  parserClass="by.home.acs.language.parser.ACSScriptParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="ACSScript"
  psiImplClassSuffix="Impl"
  psiPackage="by.home.acs.language.psi"
  psiImplPackage="by.home.acs.language.psi.impl"

  elementTypeHolderClass="by.home.acs.language.ACSScriptTypes"
  elementTypeClass="by.home.acs.language.psi.ACSScriptElementType"
  tokenTypeClass="by.home.acs.language.psi.ACSScriptTokenType"

  psiImplUtilClass="by.home.acs.language.psi.impl.ACSScriptPsiImplUtil"
}

{
    tokens = [
        IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        WHITE_SPACE = 'regexp:\s+'
        NUMBER = '-?[0-9]+'
        STRING = 'regexp:^"(.*?)"'
        CHARACTER
        FLOAT = 'regexp:^[+-]?\d+(\.\d+)?$'
    ]
}

ACSScriptFile ::= (COMMENT|Definition*)

Definition ::= (FunctionDefinition | ScriptDefinition | DirectivesDeclaration | GlobalModifier | VariableDefinition)

FunctionDefinition ::= function (VoidType | Type) IDENTIFIER OpenBracket CloseBracket  OpenBrace FunctionBody CloseBrace

ScriptDefinition ::= SCRIPT (( STRING | NUMBER) (ScriptType)? (OpenBracket Type IDENTIFIER CloseBracket | OpenBracket VoidType CloseBracket)?  (NetType)? OpenBrace ScriptBody CloseBrace)
       /*{
       mixin="by.home.acs.language.helper.ACSScriptNamedElementImpl"
       implements="by.home.acs.language.helper.ACSScriptNamedElement"
       methods=[getScript getScriptNumberValue getScriptWord setScriptWord getScriptIdentifier]}*/

ScriptType ::= OPEN | ENTER | RETURN | RESPAWN | DEATH | LIGHTNING | UNLOADING | DISCONNECT | KILL | REOPEN

DirectivesDeclaration ::= IncludeDeclaration | ImportDeclaration | DefineDeclaration | LibraryDeclaration

IncludeDeclaration ::= PoundSymbol include STRING

ImportDeclaration ::= PoundSymbol import STRING

DefineDeclaration ::= PoundSymbol define IDENTIFIER  IDENTIFIER (Operator (IDENTIFIER | NUMBER))?

LibraryDeclaration ::= PoundSymbol library STRING

GlobalModifier ::= (global | world) Type IDENTIFIER ColonSymbol IDENTIFIER SemicolonSymbol

StaticModifier ::= static

NetType ::= net

VoidType ::= void

FunctionBody ::= Statement*

Statement ::= VariableDefinition | AssignmentStatement | FunctionInvocation | ControlFlowStatement | Loops | ReturnOperator

ScriptBody ::= ScriptStatement*

ScriptStatement ::= VariableDefinition | VariableInitialization | AssignmentStatement | FunctionInvocation | ControlFlowStatement | Loops

CaseOperator ::=   case (IDENTIFIER | NUMBER | STRING) ColonSymbol  (FunctionInvocation | VariableDefinition)? (SwitchStatement)?  (break SemicolonSymbol)? CaseOperator? (default ColonSymbol FunctionInvocation)?

AssignmentStatement ::= IDENTIFIER EqualsSymbol (FunctionInvocation)

VariableDefinition ::= StaticModifier? (ArrayType | Type) IDENTIFIER (SemicolonSymbol | (EqualsSymbol (FunctionInvocation | VariableInitialization | Operator)))

VariableInitialization ::= ( STRING | CHARACTER | EmptyString | LogicalType | ArrayInitializer | NUMBER | FLOAT) SemicolonSymbol

Operator ::= (AssignmentOperator | RelationalOperator | ArithmeticOperator | LogicalOperator | BitwiseOperator)

AssignmentOperator ::= ('=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|=')

RelationalOperator ::= ('>' | '<' | '==' | '!=' | '>=' | '<=')

ArithmeticOperator ::= ( '++' | '--' | '+' | '-' | '/' | '%' | '*' )

LogicalOperator ::= ('&&' | '||' | '!')

BitwiseOperator ::= ('&' | '|' | '^' | '~' | '<<' | '>>')

Loops ::= forLoop | whileLoop | untilLoop | doWhileLoop | doUntilLoop

forLoop ::= for OpenBracket IDENTIFIER SemicolonSymbol LogicalType SemicolonSymbol IDENTIFIER CloseBracket OpenBrace Statement CloseBrace // not finished yet cuz need to fix operators

whileLoop ::= while OpenBracket LogicalType CloseBracket OpenBrace Statement? CloseBrace

untilLoop ::= until OpenBracket LogicalType CloseBracket OpenBrace Statement? CloseBrace

doWhileLoop ::= do OpenBrace Statement? CloseBrace while OpenBracket LogicalType CloseBracket SemicolonSymbol

doUntilLoop ::= do OpenBrace Statement? CloseBrace until OpenBracket LogicalType CloseBracket SemicolonSymbol

Type ::= (IntType | StringType | BoolType)

BoolType ::= bool

IntType ::= int

StringType ::= str

EmptyString ::= '""'

ArrayType ::= (Type) OpenSquareBracket CloseSquareBracket

ArrayInitializer ::= OpenBrace ArrayInitializers? CloseBrace

ArrayInitializers ::= (NUMBER | STRING) (CommaSymbol ArrayInitializers)?

LogicalType ::= true | false

ReturnOperator ::= return SemicolonSymbol | return IDENTIFIER SemicolonSymbol // Use something else but IDENTIFIER later

FunctionInvocation ::= IDENTIFIER OpenBracket CloseBracket SemicolonSymbol ReturnOperator? // TODO need to change this because of possible parameters inside

ControlFlowStatement ::= IfThenStatement | IfThenElseStatement |  SwitchStatement

IfThenStatement ::= if OpenBracket LogicalType CloseBracket Statement

IfThenElseStatement ::= if OpenBracket LogicalType OpenBracket OpenBrace FunctionBody CloseBrace (else (OpenBrace FunctionBody CloseBrace | IfThenElseStatement) )?

SwitchStatement ::= switch OpenBracket (IDENTIFIER | NUMBER) CloseBracket OpenBrace CaseOperator CloseBrace

/*
    Key symbol's
 */

EqualsSymbol ::= '='

DotSymbol ::= '.' //not used

CommaSymbol ::= ','

OpenBrace ::= '{'

CloseBrace ::= '}'

OpenBracket ::= '('

CloseBracket ::= ')'

PoundSymbol ::= '#'

SemicolonSymbol ::= ';'

ColonSymbol ::= ':'

OpenSquareBracket ::= '['

CloseSquareBracket ::= ']'