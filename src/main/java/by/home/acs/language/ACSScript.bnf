{
  parserClass="by.home.acs.language.parser.ACSScriptParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="ACSScript"
  psiImplClassSuffix="Impl"
  psiPackage="by.home.acs.language.psi"
  psiImplPackage="by.home.acs.language.psi.impl"

  elementTypeHolderClass="by.home.acs.language.ACSScriptTypes"
  elementTypeClass="by.home.acs.language.psi.ACSScriptElementType"
  tokenTypeClass="by.home.acs.language.psi.ACSScriptTokenType"

  psiImplUtilClass="by.home.acs.language.psi.impl.ACSScriptPsiImplUtil"
}

{
    tokens = [
        IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        WHITE_SPACE = 'regexp:\s+'
        NUMBER = 'regexp:([1-9]|[1-8][0-9]|9[0-9]|[1-8][0-9]{2}|9[0-8][0-9]|99[0-9]|[1-8][0-9]{3}|9[0-8][0-9]{2}|99[0-8][0-9]|999[0-9]|[12][0-9]{4}|3[01][0-9]{3}|32[0-6][0-9]{2}|327[0-5][0-9]|3276[0-7])'
        INTEGER = 'regexp:([0-9]|[1-8][0-9]|9[0-9]|[1-8][0-9]{2}|9[0-8][0-9]|99[0-9]|[1-8][0-9]{3}|9[0-8][0-9]{2}|99[0-8][0-9]|999[0-9]|[1-8][0-9]{4}|9[0-8][0-9]{3}|99[0-8][0-9]{2}|999[0-8][0-9]|9999[0-9]|[1-8][0-9]{5}|9[0-8][0-9]{4}|99[0-8][0-9]{3}|999[0-8][0-9]{2}|9999[0-8][0-9]|99999[0-9]|[1-8][0-9]{6}|9[0-8][0-9]{5}|99[0-8][0-9]{4}|999[0-8][0-9]{3}|9999[0-8][0-9]{2}|99999[0-8][0-9]|999999[0-9]|[1-8][0-9]{7}|9[0-8][0-9]{6}|99[0-8][0-9]{5}|999[0-8][0-9]{4}|9999[0-8][0-9]{3}|99999[0-8][0-9]{2}|999999[0-8][0-9]|9999999[0-9]|[1-8][0-9]{8}|9[0-8][0-9]{7}|99[0-8][0-9]{6}|999[0-8][0-9]{5}|9999[0-8][0-9]{4}|99999[0-8][0-9]{3}|999999[0-8][0-9]{2}|9999999[0-8][0-9]|99999999[0-9]|1[0-9]{9}|20[0-9]{8}|21[0-3][0-9]{7}|214[0-6][0-9]{6}|2147[0-3][0-9]{5}|21474[0-7][0-9]{4}|214748[0-2][0-9]{3}|2147483[0-5][0-9]{2}|21474836[0-3][0-9]|214748364[0-7])'
        STRING = 'regexp:^"(.*?)"'
    ]
}

ACSScriptFile ::= (COMMENT|Definition*)

Definition ::= (FunctionDefinition | ScriptDefinition | DirectivesDeclaration | GlobalModifier | VariableDefinition)

FunctionDefinition ::= function (VoidType | Type) IDENTIFIER '(' ')'  '{' FunctionBody '}'

ScriptDefinition ::= SCRIPT (NUMBER | STRING) (ScriptType)? ('(' Type IDENTIFIER')' | '(' VoidType ')')?  (NetType)? '{' ScriptBody '}'

ScriptType ::= OPEN | ENTER | RETURN | RESPAWN | DEATH | LIGHTNING | UNLOADING | DISCONNECT | KILL | REOPEN

DirectivesDeclaration ::= IncludeDeclaration | ImportDeclaration | DefineDeclaration | LibraryDeclaration

IncludeDeclaration ::= '#' include STRING

ImportDeclaration ::= '#' import STRING

DefineDeclaration ::= '#' define IDENTIFIER IDENTIFIER  // need to add operator support here too and numbers

LibraryDeclaration ::= '#' library STRING

GlobalModifier ::= (global | world) Type IDENTIFIER':'IDENTIFIER';'

StaticModifier ::= static

NetType ::= net

VoidType ::= void

FunctionBody ::= Statement*

Statement ::= VariableDefinition | AssignmentStatement | FunctionInvocation | ConditionalOperator | Loops | ReturnOperator

ScriptBody ::= ScriptStatement*

ScriptStatement ::= VariableDefinition | AssignmentStatement | FunctionInvocation | ConditionalOperator | Loops

CaseOperator ::=   case (IDENTIFIER | NUMBER | STRING) ':'  (FunctionInvocation | VariableDefinition)? (SwitchStatement)?  (break ';')? CaseOperator? (default ':' FunctionInvocation)?

VariableDefinition ::= StaticModifier? (ArrayType | Type) IDENTIFIER (';' | ('=' (FunctionInvocation | VariableInitialization | Operator)))

VariableInitialization ::= (INTEGER | STRING | LogicalType | ArrayInitializer)  ';' // Classify initialization directly to each type

Operator ::=  IDENTIFIER ('=' | '+' | '-' | '*' | '/' | '%' | '&' | '|' | '^' | '~' | '<<' | '>>' | '==' | '!=' | '>' | '<' | '>=' | '<=' | '&&' | '||' | '!' | '+=' | '++' | '-=' | '--' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=') IDENTIFIER? NUMBER? STRING?';'

Loops ::= forLoop | whileLoop | untilLoop | doWhileLoop | doUntilLoop

forLoop ::= for '(' IDENTIFIER ';' LogicalType ';' IDENTIFIER ')' '{' Statement '}' // not finished yet cuz need to fix operators

whileLoop ::= while '(' LogicalType ')' '{' Statement? '}'

untilLoop ::= until '(' LogicalType ')' '{' Statement? '}'

doWhileLoop ::= do '{' Statement? '}' while '(' LogicalType ')' ';'

doUntilLoop ::= do '{' Statement? '}' until '(' LogicalType ')' ';'

Type ::= (int | str | bool)

ArrayType ::= (Type) '[' ']'

ArrayInitializer ::= '{' ArrayInitializers? '}'

ArrayInitializers ::= (INTEGER | STRING) (',' ArrayInitializers)?

LogicalType ::= true | false

ReturnOperator ::= return ';' | return IDENTIFIER ';' // Use something else but IDENTIFIER later

AssignmentStatement ::= IDENTIFIER '=' FunctionInvocation

FunctionInvocation ::= IDENTIFIER '(' ')' ';' ReturnOperator?

ConditionalOperator ::= IfThenStatement | IfThenElseStatement |  SwitchStatement

IfThenStatement ::= if '(' LogicalType ')' Statement

IfThenElseStatement ::= if '(' LogicalType ')' '{' FunctionBody '}' (else ('{' FunctionBody '}' | IfThenElseStatement) )?

SwitchStatement ::= switch '(' (IDENTIFIER | NUMBER) ')' '{' CaseOperator '}'



