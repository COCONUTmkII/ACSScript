{
  parserClass="by.home.acs.language.parser.ACSScriptParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="ACSScript"
  psiImplClassSuffix="Impl"
  psiPackage="by.home.acs.language.psi"
  psiImplPackage="by.home.acs.language.psi.impl"

  elementTypeHolderClass="by.home.acs.language.ACSScriptTypes"
  elementTypeClass="by.home.acs.language.psi.ACSScriptElementType"
  tokenTypeClass="by.home.acs.language.psi.ACSScriptTokenType"

  psiImplUtilClass="by.home.acs.language.psi.impl.ACSScriptPsiImplUtil"
}

{
    tokens = [
        IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        WHITE_SPACE = 'regexp:\s+'
        NUMBER = '-?[0-9]+'
        STRING = 'regexp:^"(.*?)"'
        CHARACTER
        FLOAT = 'regexp:^[+-]?\d+(\.\d+)?$'
        //TEST_SIGNATURE = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*\('
    ]
}

ACSScriptFile ::= (COMMENT|Definition*)

Definition ::= (FunctionDefinition | ScriptDefinition | DirectivesDeclaration | GlobalModifier | VariableDefinition)


FunctionDefinition ::= FunctionIdentifier FunctionReturnType FunctionNameAndParams FunctionBody //IDENTIFIER OpenBracket CloseBracket  OpenBrace FunctionBody CloseBrace

ScriptDefinition ::= ScriptIdentifier ScriptName ((ScriptParameterWithVoid NetType?) | (ScriptType NetType?)  | (ScriptParameter NetType?)) ScriptBody
{
       mixin="by.home.acs.language.helper.ACSScriptNamedElementImpl"
       implements="by.home.acs.language.helper.ACSScriptNamedElement"
       methods=[getNameIdentifier  getName setName getScript getScriptNumberValue getIdentifier]
}

/**
    Directives statement
 */
DirectivesDeclaration ::= IncludeDeclaration | ImportDeclaration | DefineDeclaration | LibraryDeclaration

IncludeDeclaration ::= PoundSymbol include STRING

ImportDeclaration ::= PoundSymbol import STRING

DefineDeclaration ::= PoundSymbol define IDENTIFIER  IDENTIFIER (Operator (IDENTIFIER | NUMBER))?

LibraryDeclaration ::= PoundSymbol library STRING

/**
    Script statements
 */
ScriptIdentifier ::= 'script'

ScriptType ::= OPEN | ENTER | RETURN | RESPAWN | DEATH | LIGHTNING | UNLOADING | DISCONNECT | KILL | REOPEN

ScriptName ::= STRING | NUM

ScriptParameterWithVoid ::= OpenBracket VoidType CloseBracket //   (void)

ScriptParameter ::= OpenBracket ScriptParameterList CloseBracket

ScriptParameterList ::= ScriptFormalParameter (CommaSymbol ScriptFormalParameter)*

ScriptFormalParameter ::= IntType IDENTIFIER

ScriptBody ::= OpenBrace ScriptStatement* CloseBrace

/**
    Function statements
 */
FunctionIdentifier ::= 'function'

FunctionInvocation ::= IDENTIFIER OpenBracket CloseBracket SemicolonSymbol ReturnOperator?

FunctionReturnType ::= VoidType | Type

FunctionParameterWithVoid ::= VoidType

FunctionNameAndParams ::= IDENTIFIER (FunctionParameter | FunctionParameterWithVoid)
//FunctionParameter ::= OpenBracket FunctionParameterList CloseBracket

FunctionParameter ::= OpenBracket (FunctionParameterWithVoid | FunctionParameterList) CloseBracket

FunctionParameterList ::= FunctionFormalParameter (CommaSymbol FunctionFormalParameter)*

FunctionFormalParameter ::= Type IDENTIFIER

FunctionBody ::= OpenBrace Statement* CloseBrace

/**

 */

GlobalModifier ::= (global | world) Type IDENTIFIER ColonSymbol IDENTIFIER SemicolonSymbol

StaticModifier ::= static

NetType ::= net

VoidType ::= 'void'

Statement ::= VariableDefinition | AssignmentStatement | FunctionInvocation | ControlFlowStatement | Loops | ReturnOperator

//ScriptBody ::= ScriptStatement*

ScriptStatement ::= VariableDefinition | VariableInitialization | AssignmentStatement | FunctionInvocation | ControlFlowStatement | Loops

CaseOperator ::=   case (IDENTIFIER | NUMBER | STRING) ColonSymbol  (FunctionInvocation | VariableDefinition)? (SwitchStatement)?  (break SemicolonSymbol)? CaseOperator? (default ColonSymbol FunctionInvocation)?

AssignmentStatement ::= IDENTIFIER EqualsSymbol (FunctionInvocation)

VariableDefinition ::= StaticModifier? (ArrayType | Type) IDENTIFIER (SemicolonSymbol | (EqualsSymbol (FunctionInvocation | VariableInitialization | Operator)))

VariableInitialization ::= ( STRING | CHARACTER | EmptyString | LogicalType | ArrayInitializer | NUMBER | FLOAT) SemicolonSymbol

Operator ::= (AssignmentOperator | RelationalOperator | ArithmeticOperator | LogicalOperator | BitwiseOperator)

AssignmentOperator ::= ('=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|=')

RelationalOperator ::= ('>' | '<' | '==' | '!=' | '>=' | '<=')

ArithmeticOperator ::= ( '++' | '--' | '+' | '-' | '/' | '%' | '*' )

LogicalOperator ::= ('&&' | '||' | '!')

BitwiseOperator ::= ('&' | '|' | '^' | '~' | '<<' | '>>')

Loops ::= forLoop | whileLoop | untilLoop | doWhileLoop | doUntilLoop

forLoop ::= for OpenBracket IDENTIFIER SemicolonSymbol LogicalType SemicolonSymbol IDENTIFIER CloseBracket OpenBrace Statement CloseBrace // not finished yet cuz need to fix operators

whileLoop ::= while OpenBracket LogicalType CloseBracket OpenBrace Statement? CloseBrace

untilLoop ::= until OpenBracket LogicalType CloseBracket OpenBrace Statement? CloseBrace

doWhileLoop ::= do OpenBrace Statement? CloseBrace while OpenBracket LogicalType CloseBracket SemicolonSymbol

doUntilLoop ::= do OpenBrace Statement? CloseBrace until OpenBracket LogicalType CloseBracket SemicolonSymbol

Type ::= (IntType | StringType | BoolType)

BoolType ::= 'bool'

IntType ::= 'int'

StringType ::= 'str'

EmptyString ::= '""'

ArrayType ::= (Type) OpenSquareBracket CloseSquareBracket

ArrayInitializer ::= OpenBrace ArrayInitializers? CloseBrace

ArrayInitializers ::= (NUMBER | STRING) (CommaSymbol ArrayInitializers)?

LogicalType ::= true | false

ReturnOperator ::= return SemicolonSymbol | return IDENTIFIER SemicolonSymbol // Use something else but IDENTIFIER later



ControlFlowStatement ::= IfThenStatement | IfThenElseStatement |  SwitchStatement

IfThenStatement ::= if OpenBracket LogicalType CloseBracket Statement

IfThenElseStatement ::= if OpenBracket LogicalType OpenBracket OpenBrace FunctionBody CloseBrace (else (OpenBrace FunctionBody CloseBrace | IfThenElseStatement) )?

SwitchStatement ::= switch OpenBracket (IDENTIFIER | NUMBER) CloseBracket OpenBrace CaseOperator CloseBrace

/*
    Key symbol's
 */

EqualsSymbol ::= '='

DotSymbol ::= '.' //not used

CommaSymbol ::= ','

OpenBrace ::= '{'

CloseBrace ::= '}'

OpenBracket ::= '('

CloseBracket ::= ')'

PoundSymbol ::= '#'

SemicolonSymbol ::= ';'

ColonSymbol ::= ':'

OpenSquareBracket ::= '['

CloseSquareBracket ::= ']'

NUM ::= NUMBER